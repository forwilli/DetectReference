# ADR-001: 后端缓存策略

**日期**: 2025-01-07  
**状态**: ✅ 已实施  
**决策者**: Claude (工程师), Gemini (诊断系统)  
**实施日期**: 2025-01-07

## 背景与问题

系统当前每次验证参考文献都需要调用外部API（Gemini AI、CrossRef、Google Search），导致：
1. **成本问题**: 重复验证相同文献会产生不必要的API调用费用
2. **性能问题**: 每次验证需要3-5秒，用户体验不佳
3. **稳定性问题**: 可能触发API速率限制

## 决策驱动因素

- 降低运营成本
- 提升响应速度
- 保证服务稳定性
- 实现简单，维护成本低

## 考虑的方案

### 方案1: node-cache (内存缓存)
- **优点**: 轻量级、零配置、响应极快
- **缺点**: 服务重启后缓存丢失、单机限制

### 方案2: Redis
- **优点**: 持久化、分布式、功能丰富
- **缺点**: 需要额外运维、增加系统复杂度

### 方案3: 文件系统缓存
- **优点**: 简单、持久化
- **缺点**: I/O性能差、并发问题

## 决策

**采用方案1 (node-cache) 作为第一阶段实现**

### 实施细节

1. **缓存键设计**:
   ```
   cache_key = `verify:${API_VERSION}:${hash(reference_text)}`
   ```

2. **缓存策略**:
   - TTL: 7天（学术文献信息相对稳定）
   - 最大缓存条目: 10000条
   - 淘汰策略: LRU

3. **缓存内容**:
   ```javascript
   {
     reference: "原始文献",
     geminiAnalysis: {...},
     verificationResult: {
       status: "verified",
       source: "crossref",
       confidence: 0.95,
       url: "...",
       timestamp: "2025-01-07T10:00:00Z"
     }
   }
   ```

## 实施计划

1. 安装 node-cache: `npm install node-cache`
2. 创建 `backend/src/services/cacheService.js`
3. 在 `verifyControllerSSE.js` 中集成缓存逻辑
4. 添加缓存命中率监控

## 后续演进

- Phase 2: 评估是否需要升级到Redis
- Phase 3: 实现分层缓存（内存+Redis）

## 审批状态

- [x] Claude (工程师) - 已确认 (2025-01-07)
- [x] Gemini (诊断系统) - 已确认 (诊断报告中已批准)

## 实施总结

✅ **已完成实施**，包括：
1. 安装了 node-cache 依赖
2. 创建了 `cacheService.js`，实现了所有计划功能
3. 集成到 `verifyControllerSSE.js` 中
4. 添加了缓存命中率监控和内存使用监控
5. 创建了单元测试验证功能正确性

**额外优化**：
- 支持缓存预热功能
- 内存监控仅在非测试环境运行
- 缓存统计信息通过SSE事件返回给前端

## 签名

**Claude**: 我认为这是一个务实的方案，建议先从简单的内存缓存开始，根据实际使用情况再决定是否升级。
- 补充意见：建议在实施时增加缓存预热功能，可在系统启动时加载常见参考文献的验证结果。
- 风险提醒：需要考虑内存使用上限，避免OOM问题。建议设置内存使用监控。

**Gemini**: [待填写意见]